1. Study the folder structure of the project properly.
__________________________________________________________________________________________________________

2. Study the contents and comments in backend/backend.dockerfile in detail.
__________________________________________________________________________________________________________

3. NOTES ON backend.dockerfile:

  Notice that we copy the requirements.txt first and then the rest of the contents into /app
  - If we copy everything first and then install the dependencies such as:
    COPY . .   # Copies ALL files, including app code
    RUN pip install --no-cache-dir -r requirements.txt

  If we make a small code change in our FastAPI app, Docker rebuilds everything from scratch, including reinstalling dependencies.
  A better approach would be to:
  - Copy only requirements.txt first.
  - Install dependencies.
  - Then copy the rest of the files.

  To build the image, we use the command:
  - "docker build -t taskflow-backend -f backend.dockerfile ."
  - the -t flag	names (tags) the built image
  - the -f flag specifies a custom Dockerfile
  - It searches for the dockerfile within '.' path
__________________________________________________________________________________________________________

4. NOTES ON docker-compose.yml [IMPORTANT]:

  Notice that version 3.8 specifies that we are using Docker Compose file format version 3.8
  
  We define all the services we need: backend, postgresql, mongodb, redis, and frontend
  - Notice that services like backend and frontend, we need to build them because we have our custom dockerfile for each of them that (for backend):
    - copies all the necessary items into the container image
    - installs all the necessary dependencies prior
    - runs the FastAPI backend api
  - In contrast, we use simple images for postgresql, mongodb, and redis provided by docker

  Notice all the fields within a service
    - build uses context for the location of the dockerfile and the dockerfile itself

    - ports: "8000:8000" mean that for us (local machine), we can access the backend at: http://localhost:8000,
      where our computer is the localhost. But, for the container, the same backend service is running at: http://localhost:8000 where the container is the localhost
      Similarly, to take an example, we can access the postgresql instance at http://localhost:5432
      and the container has the same postgresql instance running at http://localhost:5432

    - depends_on lists the services our backend is dependent upon and starts those services prior to the backend
    - condition ensures that the services are either healthy, or started before starting the backend service
    - COME BACK TO THIS LATER!

    - study the environment variables for each of the service for info on the instance running

    - healthcheck ensures postgresql, and mongodb are working and responsive (every 5 seconds) starting from 
      10 seconds after launch, and retries upto 5 times in case of failure before starting backend 
    
    - [IMPORTANT] study how the volumes' references have been set up inside postgresql, mongodb, and redis 
      services for persistent storage of data. 
      The left side of the colon denotes that on our local machine, Docker will create a named volume and manage the data in it. On the other hand, the right side of the colon denotes the path where the data resides inside the container itself.
      For example: in 'postgres_data:/var/lib/postgresql/data', in our local computer, the data will be stored in a volume called postgres_data somewhere; we don't need to worry about it since docker manages it. But inside the container itself, the data can be found at "/var/lib/postgresql/data".
    - When a launched docker container is stopped with docker-compose down or is interrupted, the data in
      these named columes persists because the named volumes are still in our local machine and data can be restored the next time the container is composed up.
    - Volumes can only be deleted explicitly with docker volume rm <volume_name>, not otherwise

  Lastly, notice how the global volumes fields at the botton defines all the local storage volumes postgres_data, mongodb_data, and redis_data
__________________________________________________________________________________________________________

5. NOTES ON the FastAPI backend [IMPORTANT]
  In backend.dockerfile, we run 
    CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
  This means the container looks for an app instance of the FastAPI in main.py within the app directory of the container, i.e. app.main (left of the colon) -> /app/main.py and app (right of the colon) ->
  app = FastAPI() instance within main.py

  Some Key Terms and Definitions for Python Backend Web Servers [IMPORTANT]:

    - Traditional Web Servers:
      - These serve static files, media, html, etc. (Example: Nginx, Apache, Caddy, LiteSpeed, etc.)
      - They do not run Python applications directly, but can forward requests to backend (WSGI/ASGI) servers
        and return the responses from those backend servers to the client
      - They also act as reverse proxy, i.e.
        - They provide load balancing by distributing requests across multiple WSGI/ASGI servers
        - They hide backend servers from direct public access, adding a layer of security
        - They handle static files, compression, and caching better than an application server
      - NGINX, APACHE, etc. are software packages that enable a computer to act as a web server, i.e., listen 
        for all incoming requests on port 80 (HTTP) or 443 (HTTPS) from any IP address and serve static files or forward the request to a backend application server and send responses back to the clients
    
    - Application/Backend Servers:
      - These are responsible for running dynamic web applications with dynamic API endpoints
      - They are of two types (in terms of Python application servers)

        - WSGI server: Web Server Gateway Interface (WSGI) is an older standard for synchronous Python 
          web applications, that defines how a web server (like NGINX/Apche) communicates with a Python web application.
          Key Points:
          - Synchronous: It handles one request at a time
          - Middleware Support: It allows the use of middleware like authentication, logging, etc. to 
            modify requests and responses
          - It is the de facto standard for Python web app frameworks like Django and Flask in synchronous mode
          - Examples: Gunicorn and uWSGI -> when we install and run Gunicorn or uWSGI, it turns our computer into
            a WSGI server, allowing us to serve Flask or Django apps
          - Some WSGI servers (like Gunicorn) support multiple worker processes, which allows handling multiple 
            requests concurrently, but each worker is still synchronous

          HOW A WSGI SERVER WORKS (Example):
            Let's say a user wants to add an item (a task) to a certain web application, and there is a Flask app that provides a route and a POST method for it -> "www.example-app.com/api/add-task/<task-info>". Assume that this method communicates with a database, adds the task into it, and responds with status 201 and a simple JSON response {"message":"task added"}. Then the steps involved are:
            - User/Client: Sends a POST request to www.example-app.com/api/add-task/<task-info>
            - Web Server (NGINX): Receives the HTTP request, acts as a reverse proxy, forwards it 
              to the appropriate backend application server based on the "/api/add-task/<task-info>" portion
            - Gunicorn: Is running and listening on port 8000 (say) and receives the request on the WSGI 
              server it's running on. It then matches the URL with the appropriate route defined in the Flask app
            - Flask App: Processes the request inside that method, extracts the task-info, interacts with 
              the database server to add the task and returns the response JSON to Gunicorn
            - Gunicorn: Sends the response back to the NGINX web server
            - Web Server (NGINX): Receives the response from Gunicorn and forwards it to the client
            - User/Client: Receives the response

        - ASGI server: ASGI (Asynchronous Server Gateway Interface) is a newer standard for asynchronous Python 
          web applications, introduced to support modern use cases like WebSockets and long-lived connections.
          Key Points:
          - Asynchronous: It can handle many requests concurrently using async I/O, ideal for WebSockets 
            and streaming APIs. Thus, ASGI can handle real-time communication
          - Designed for modern frameworks like FastAPI, Django Channels, and Starlette
          - Examples: Uvicorn and Daphne
          - ASGI servers like Uvicorn leverage async programming with event loops (like those in 
            Python's asyncio), making them more scalable for concurrent tasks.

          HOW An ASGI SERVER WORKS (Example):
          Let's say a user registers to a web application by providing their email and username. With that they create a POST request to "www.example-app.com/register/". Within the body of the POST request, say there is:
            {
              "username": "johndoe",
              "email":"johndoe@gmail.com"
            }
          As we saw in WSGI server, the usual behavior is for the NGINX to act as a reverse proxy and forward the request and response to and from between the client and uvicorn, which then matches the url to the specific method defined in the running FastAPI instance.
          - FastAPI: Receives the incoming request, validates the data using the User model (say), and 
            starts processing. However, instead of waiting for the confirmation email to be sent (which being a network I/O task can take a long time), the task gets added to the background and is run asynchronously. In the meantime, other requests or tasks are being handled by the FastAPI backend, effectively implementing non-blocking in the server. However, a response of status 201, and say a JSON response of {"message":"User registered!"} is sent immediately, again without waiting for the email to be sent. The email gets sent eventually. 
            Thus, "www.example-app.com/register/" endpoint receives the user data, saves it and responds immediately, while the network I/O task of sending a confirmation email is executed asynchronously in the background.
          

    - uvicorn: an ASGI web server implementation for Python/FastAPI framework. It handles network communication
      by receiving requests from client applications such as users' browsers and sending responses to them
    
